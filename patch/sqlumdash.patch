diff -ru sqlite-src-3250000/Makefile.msc SQLumDash3.25.0/Makefile.msc
--- sqlite-src-3250000/Makefile.msc	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/Makefile.msc	2018-10-05 10:07:07.000000000 +0900
@@ -950,8 +950,8 @@
 
 # Should the database engine be compiled threadsafe
 #
-TCC = $(TCC) -DSQLITE_THREADSAFE=1
-RCC = $(RCC) -DSQLITE_THREADSAFE=1
+TCC = $(TCC) -DSQLITE_THREADSAFE=2
+RCC = $(RCC) -DSQLITE_THREADSAFE=2
 
 # Do threads override each others locks by default (1), or do we test (-1)
 #
@@ -964,6 +964,8 @@
 TLIBS =
 !ENDIF
 
+TLIBS = $(TLIBS) advapi32.lib
+
 # Flags controlling use of the in memory btree implementation
 #
 # SQLITE_TEMP_STORE is 0 to force temporary tables to be in a file, 1 to
@@ -1214,7 +1216,8 @@
          update.lo upsert.lo util.lo vacuum.lo \
          vdbeapi.lo vdbeaux.lo vdbeblob.lo vdbemem.lo vdbesort.lo \
          vdbetrace.lo wal.lo walker.lo where.lo wherecode.lo whereexpr.lo \
-         window.lo utf.lo vtab.lo
+         window.lo utf.lo vtab.lo \
+         rowlock.lo rowlock_hash.lo rowlock_ipc.lo rowlock_ipc_row.lo rowlock_ipc_table.lo rowlock_savepoint.lo
 # <</mark>>
 
 # Object files for the amalgamation.
@@ -1265,6 +1268,7 @@
   $(TOP)\src\fault.c \
   $(TOP)\src\fkey.c \
   $(TOP)\src\func.c \
+  $(TOP)\src\funcNew.c \
   $(TOP)\src\global.c \
   $(TOP)\src\hash.c \
   $(TOP)\src\insert.c \
@@ -1326,7 +1330,15 @@
   $(TOP)\src\where.c \
   $(TOP)\src\wherecode.c \
   $(TOP)\src\whereexpr.c \
-  $(TOP)\src\window.c
+  $(TOP)\src\window.c \
+  $(TOP)\src\rowlock.c \
+  $(TOP)\src\rowlock_btree.c \
+  $(TOP)\src\rowlock_hash.c \
+  $(TOP)\src\rowlock_ipc.c \
+  $(TOP)\src\rowlock_ipc_row.c \
+  $(TOP)\src\rowlock_ipc_table.c \
+  $(TOP)\src\rowlock_pager.c \
+  $(TOP)\src\rowlock_savepoint.c
 
 # Core miscellaneous files.
 #
@@ -1338,6 +1350,7 @@
 SRC04 = \
   $(TOP)\src\btree.h \
   $(TOP)\src\btreeInt.h \
+  $(TOP)\src\funcNew.h \
   $(TOP)\src\hash.h \
   $(TOP)\src\hwtime.h \
   $(TOP)\src\msvc.h \
@@ -1361,7 +1374,14 @@
   $(TOP)\src\vdbeInt.h \
   $(TOP)\src\vxworks.h \
   $(TOP)\src\wal.h \
-  $(TOP)\src\whereInt.h
+  $(TOP)\src\whereInt.h \
+  $(TOP)\src\rowlock.h \
+  $(TOP)\src\rowlock_hash.h \
+  $(TOP)\src\rowlock_ipc.h \
+  $(TOP)\src\rowlock_ipc_row.h \
+  $(TOP)\src\rowlock_ipc_table.h \
+  $(TOP)\src\rowlock_macro.h \
+  $(TOP)\src\rowlock_savepoint.h
 
 # Extension source code files, part 1.
 #
@@ -1576,7 +1596,14 @@
    $(TOP)\src\vdbe.h \
    $(TOP)\src\vdbeInt.h \
    $(TOP)\src\vxworks.h \
-   $(TOP)\src\whereInt.h
+   $(TOP)\src\whereInt.h \
+   $(TOP)\src\rowlock.h \
+   $(TOP)\src\rowlock_hash.h \
+   $(TOP)\src\rowlock_ipc.h \
+   $(TOP)\src\rowlock_ipc_row.h \
+   $(TOP)\src\rowlock_ipc_table.h \
+   $(TOP)\src\rowlock_macro.h \
+   $(TOP)\src\rowlock_savepoint.h
 
 # Header files used by extensions
 #
@@ -1662,7 +1689,7 @@
 # This is the default Makefile target.  The objects listed here
 # are what get build when you type just "make" with no arguments.
 #
-core:	dll libsqlite3.lib shell
+core:	dll libsqlite3.lib shell sqlumdash_cleaner.exe
 
 # Targets that require the Tcl library.
 #
@@ -1695,8 +1722,10 @@
 sqlite3.def:	libsqlite3.lib
 	echo EXPORTS > sqlite3.def
 	dumpbin /all libsqlite3.lib \
-		| $(TCLSH_CMD) $(TOP)\tool\replace.tcl include "^\s+1 _?(sqlite3(?:session|changeset|changegroup|rebaser)?_[^@]*)(?:@\d+)?$$" \1 \
-		| sort >> sqlite3.def
+		| $(TCLSH_CMD) $(TOP)\tool\replace.tcl include "^\s+[0-9A-F]+ _?(sqlite3(?:session|changeset|changegroup|rebaser)?_[^@]*)(?:@\d+)?$$" \1 \
+		| sort >> sqlite3.def.tmp
+	.\tool\win\uniq.bat sqlite3.def.tmp >> sqlite3.def
+	del sqlite3.def.tmp
 # <</block2>>
 
 $(SQLITE3EXE):	shell.c $(SHELL_CORE_DEP) $(LIBRESOBJS) $(SHELL_CORE_SRC) $(SQLITE3H)
@@ -2070,6 +2099,24 @@
 window.lo:	$(TOP)\src\window.c $(HDR)
 	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\window.c
 
+rowlock.lo:	$(TOP)\src\rowlock.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock.c
+
+rowlock_hash.lo:	$(TOP)\src\rowlock_hash.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_hash.c
+
+rowlock_ipc.lo:	$(TOP)\src\rowlock_ipc.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_ipc.c
+
+rowlock_ipc_row.lo:	$(TOP)\src\rowlock_ipc_row.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_ipc_row.c
+
+rowlock_ipc_table.lo:	$(TOP)\src\rowlock_ipc_table.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_ipc_table.c
+
+rowlock_savepoint.lo:	$(TOP)\src\rowlock_savepoint.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_savepoint.c
+
 tclsqlite.lo:	$(TOP)\src\tclsqlite.c $(HDR) $(SQLITE_TCL_DEP)
 	$(LTCOMPILE) $(NO_WARN) -DUSE_TCL_STUBS=1 -DBUILD_sqlite -I$(TCLINCDIR) -c $(TOP)\src\tclsqlite.c
 
@@ -2141,6 +2188,18 @@
 zlib:
 	pushd $(ZLIBDIR) && $(MAKE) /f win32\Makefile.msc clean $(ZLIBLIB) && popd
 
+# Rules to build the rowlock cleaner
+#
+CLEANER_SRC = \
+	$(TOP)\tool\rowlock_cleaner.c \
+	$(TOP)\src\rowlock_ipc.c \
+	$(TOP)\src\rowlock_ipc_row.c \
+	$(TOP)\src\rowlock_ipc_table.c
+
+sqlumdash_cleaner.exe:	 $(CLEANER_SRC) $(SQLITE3H)
+	$(TCC) $(NO_WARN) -Fe$@ $(REQ_FEATURE_FLAGS) $(OPT_FEATURE_FLAGS) $(EXT_FEATURE_FLAGS) $(OPTS) \
+		$(CLEANER_SRC) /link $(LDFLAGS) $(NLTLINKOPTS) $(NLTLIBPATHS) $(TLIBS)
+
 # Rules to build the extension objects.
 #
 icu.lo:	$(TOP)\ext\icu\icu.c $(HDR) $(EXTHDR)
@@ -2512,4 +2571,5 @@
 	del /Q showshm.exe sqlite3_checker.* sqlite3_expert.exe 2>NUL
 	del /Q fts5.* fts5parse.* 2>NUL
 	del /Q lsm.h lsm1.c 2>NUL
+	del /Q sqlumdash_cleaner.exe 2>NUL
 # <</mark>>
sqlite-src-3250000 のみに存在: compat
diff -ru sqlite-src-3250000/src/alter.c SQLumDash3.25.0/src/alter.c
--- sqlite-src-3250000/src/alter.c	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/alter.c	2018-09-26 12:01:22.000000000 +0900
@@ -159,6 +159,8 @@
   }
 #endif
 
+  ROWLOCK_TABLE_LOCK();
+
   /* Begin a transaction for database iDb. 
   ** Then modify the schema cookie (since the ALTER TABLE modifies the
   ** schema). Open a statement transaction if the table is a virtual
@@ -463,6 +465,8 @@
   pNew->addColOffset = pTab->addColOffset;
   pNew->nTabRef = 1;
 
+  ROWLOCK_TABLE_LOCK();
+
 exit_begin_add_column:
   sqlite3SrcListDelete(db, pSrc);
   return;
diff -ru sqlite-src-3250000/src/btree.c SQLumDash3.25.0/src/btree.c
--- sqlite-src-3250000/src/btree.c	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/btree.c	2018-09-26 12:01:22.000000000 +0900
@@ -165,7 +165,7 @@
 ** hold a write-lock on the schema table (root page 1). This is also
 ** acceptable.
 */
-static int hasSharedCacheTableLock(
+static int hasSharedCacheTableLockStatic(
   Btree *pBtree,         /* Handle that must hold lock */
   Pgno iRoot,            /* Root page of b-tree */
   int isIndex,           /* True if iRoot is the root of an index b-tree */
@@ -863,7 +863,7 @@
 ** Use the separate sqlite3BtreeCursorRestore() routine to restore a cursor
 ** back to where it ought to be if this routine returns true.
 */
-int sqlite3BtreeCursorHasMoved(BtCursor *pCur){
+int sqlite3BtreeCursorHasMovedOriginal(BtCursor *pCur){
   assert( EIGHT_BYTE_ALIGNMENT(pCur)
        || pCur==sqlite3BtreeFakeValidCursor() );
   assert( offsetof(BtCursor, eState)==0 );
@@ -895,7 +895,7 @@
 ** This routine should only be called for a cursor that just returned
 ** TRUE from sqlite3BtreeCursorHasMoved().
 */
-int sqlite3BtreeCursorRestore(BtCursor *pCur, int *pDifferentRow){
+int sqlite3BtreeCursorRestoreOriginal(BtCursor *pCur, int *pDifferentRow){
   int rc;
 
   assert( pCur!=0 );
@@ -2260,7 +2260,7 @@
 ** objects in the same database connection since doing so will lead
 ** to problems with locking.
 */
-int sqlite3BtreeOpen(
+int sqlite3BtreeOpenOriginal(
   sqlite3_vfs *pVfs,      /* VFS to use for this b-tree */
   const char *zFilename,  /* Name of the file containing the BTree database */
   sqlite3 *db,            /* Associated database handle */
@@ -2633,7 +2633,7 @@
 /*
 ** Close an open database and invalidate all cursors.
 */
-int sqlite3BtreeClose(Btree *p){
+int sqlite3BtreeCloseOriginal(Btree *p){
   BtShared *pBt = p->pBt;
   BtCursor *pCur;
 
@@ -3300,7 +3300,7 @@
 ** when A already has a read lock, we encourage A to give up and let B
 ** proceed.
 */
-int sqlite3BtreeBeginTrans(Btree *p, int wrflag, int *pSchemaVersion){
+int sqlite3BtreeBeginTransOriginal(Btree *p, int wrflag, int *pSchemaVersion){
   BtShared *pBt = p->pBt;
   int rc = SQLITE_OK;
 
@@ -3910,6 +3910,7 @@
   if( p->inTrans==TRANS_WRITE ){
     BtShared *pBt = p->pBt;
     sqlite3BtreeEnter(p);
+    ROWLOCK_TRANS_BTREE_COMMIT(p);
 #ifndef SQLITE_OMIT_AUTOVACUUM
     if( pBt->autoVacuum ){
       rc = autoVacuumCommit(pBt);
@@ -4102,7 +4103,7 @@
 ** This will release the write lock on the database file.  If there
 ** are no active cursors, it also releases the read lock.
 */
-int sqlite3BtreeRollback(Btree *p, int tripCode, int writeOnly){
+int sqlite3BtreeRollbackOriginal(Btree *p, int tripCode, int writeOnly){
   int rc;
   BtShared *pBt = p->pBt;
   MemPage *pPage1;
@@ -4171,7 +4172,7 @@
 ** iStatement is 1. This anonymous savepoint can be released or rolled back
 ** using the sqlite3BtreeSavepoint() function.
 */
-int sqlite3BtreeBeginStmt(Btree *p, int iStatement){
+int sqlite3BtreeBeginStmtOriginal(Btree *p, int iStatement){
   int rc;
   BtShared *pBt = p->pBt;
   sqlite3BtreeEnter(p);
@@ -4202,7 +4203,7 @@
 ** from a normal transaction rollback, as no locks are released and the
 ** transaction remains open.
 */
-int sqlite3BtreeSavepoint(Btree *p, int op, int iSavepoint){
+int sqlite3BtreeSavepointOriginal(Btree *p, int op, int iSavepoint){
   int rc = SQLITE_OK;
   if( p && p->inTrans==TRANS_WRITE ){
     BtShared *pBt = p->pBt;
@@ -4334,7 +4335,7 @@
   pCur->eState = CURSOR_INVALID;
   return SQLITE_OK;
 }
-int sqlite3BtreeCursor(
+int sqlite3BtreeCursorOriginal(
   Btree *p,                                   /* The btree */
   int iTable,                                 /* Root page of table to open */
   int wrFlag,                                 /* 1 to write. 0 read-only */
@@ -4380,7 +4381,7 @@
 ** Close a cursor.  The read lock on the database file is released
 ** when the last cursor is closed.
 */
-int sqlite3BtreeCloseCursor(BtCursor *pCur){
+int sqlite3BtreeCloseCursorOriginal(BtCursor *pCur){
   Btree *pBtree = pCur->pBtree;
   if( pBtree ){
     BtShared *pBt = pCur->pBt;
@@ -4448,7 +4449,7 @@
 ** that is currently pointing to a row in a (non-empty) table.
 ** This is a verification routine is used only within assert() statements.
 */
-int sqlite3BtreeCursorIsValid(BtCursor *pCur){
+int sqlite3BtreeCursorIsValidOriginal(BtCursor *pCur){
   return pCur && pCur->eState==CURSOR_VALID;
 }
 #endif /* NDEBUG */
@@ -4463,7 +4464,7 @@
 ** ordinary table btree.  If the cursor points to an index btree or
 ** is invalid, the result of this routine is undefined.
 */
-i64 sqlite3BtreeIntegerKey(BtCursor *pCur){
+i64 sqlite3BtreeIntegerKeyOriginal(BtCursor *pCur){
   assert( cursorHoldsMutex(pCur) );
   assert( pCur->eState==CURSOR_VALID );
   assert( pCur->curIntKey );
@@ -4494,7 +4495,7 @@
 ** valid entry.  In other words, the calling procedure must guarantee
 ** that the cursor has Cursor.eState==CURSOR_VALID.
 */
-u32 sqlite3BtreePayloadSize(BtCursor *pCur){
+u32 sqlite3BtreePayloadSizeOriginal(BtCursor *pCur){
   assert( cursorHoldsMutex(pCur) );
   assert( pCur->eState==CURSOR_VALID );
   getCellInfo(pCur);
@@ -4842,7 +4843,7 @@
 ** wrong.  An error is returned if "offset+amt" is larger than
 ** the available payload.
 */
-int sqlite3BtreePayload(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){
+int sqlite3BtreePayloadOriginal(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){
   assert( cursorHoldsMutex(pCur) );
   assert( pCur->eState==CURSOR_VALID );
   assert( pCur->iPage>=0 && pCur->pPage );
@@ -4938,7 +4939,7 @@
 ** These routines is used to get quick access to key and data
 ** in the common case where no overflow pages are used.
 */
-const void *sqlite3BtreePayloadFetch(BtCursor *pCur, u32 *pAmt){
+const void *sqlite3BtreePayloadFetchOriginal(BtCursor *pCur, u32 *pAmt){
   return fetchPayload(pCur, pAmt);
 }
 
@@ -5201,7 +5202,7 @@
 ** sqlite3BtreeNext() is a no-op.
 */
 #ifndef SQLITE_OMIT_WINDOWFUNC
-void sqlite3BtreeSkipNext(BtCursor *pCur){
+void sqlite3BtreeSkipNextOriginal(BtCursor *pCur){
   /* We believe that the cursor must always be in the valid state when
   ** this routine is called, but the proof is difficult, so we add an
   ** ALWaYS() test just in case we are wrong. */
@@ -8905,7 +8906,7 @@
   *piTable = (int)pgnoRoot;
   return SQLITE_OK;
 }
-int sqlite3BtreeCreateTable(Btree *p, int *piTable, int flags){
+int sqlite3BtreeCreateTableOriginal(Btree *p, int *piTable, int flags){
   int rc;
   sqlite3BtreeEnter(p);
   rc = btreeCreateTable(p, piTable, flags);
@@ -9114,7 +9115,7 @@
 #endif
   return rc;  
 }
-int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved){
+int sqlite3BtreeDropTableOriginal(Btree *p, int iTable, int *piMoved){
   int rc;
   sqlite3BtreeEnter(p);
   rc = btreeDropTable(p, iTable, piMoved);
@@ -9173,7 +9174,7 @@
 ** Write meta-information back into the database.  Meta[0] is
 ** read-only and may not be written.
 */
-int sqlite3BtreeUpdateMeta(Btree *p, int idx, u32 iMeta){
+int sqlite3BtreeUpdateMetaOriginal(Btree *p, int idx, u32 iMeta){
   BtShared *pBt = p->pBt;
   unsigned char *pP1;
   int rc;
@@ -9940,7 +9941,7 @@
 /*
 ** Return non-zero if a transaction is active.
 */
-int sqlite3BtreeIsInTrans(Btree *p){
+int sqlite3BtreeIsInTransOriginal(Btree *p){
   assert( p==0 || sqlite3_mutex_held(p->db->mutex) );
   return (p && (p->inTrans==TRANS_WRITE));
 }
@@ -10038,7 +10039,7 @@
 ** lock is a write lock if isWritelock is true or a read lock
 ** if it is false.
 */
-int sqlite3BtreeLockTable(Btree *p, int iTab, u8 isWriteLock){
+int sqlite3BtreeLockTableOriginal(Btree *p, int iTab, u8 isWriteLock){
   int rc = SQLITE_OK;
   assert( p->inTrans!=TRANS_NONE );
   if( p->sharable ){
@@ -10127,7 +10128,7 @@
 ** "write version" (single byte at byte offset 19) fields in the database
 ** header to iVersion.
 */
-int sqlite3BtreeSetVersion(Btree *pBtree, int iVersion){
+int sqlite3BtreeSetVersionOriginal(Btree *pBtree, int iVersion){
   BtShared *pBt = pBtree->pBt;
   int rc;                         /* Return code */
  
@@ -10196,3 +10197,7 @@
   return p->pBt->nRef;
 }
 #endif
+
+#ifndef SQLITE_AMALGAMATION
+#include "rowlock_btree.c"
+#endif
\ ファイル末尾に改行がありません
diff -ru sqlite-src-3250000/src/btree.h SQLumDash3.25.0/src/btree.h
--- sqlite-src-3250000/src/btree.h	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/btree.h	2018-09-26 12:01:22.000000000 +0900
@@ -16,6 +16,10 @@
 #ifndef SQLITE_BTREE_H
 #define SQLITE_BTREE_H
 
+#ifndef SQLITE_OMIT_ROWLOCK
+#include "rowlock_macro.h"
+#endif
+
 /* TODO: This definition is just included so other modules compile. It
 ** needs to be revisited.
 */
diff -ru sqlite-src-3250000/src/btreeInt.h SQLumDash3.25.0/src/btreeInt.h
--- sqlite-src-3250000/src/btreeInt.h	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/btreeInt.h	2018-10-10 09:14:57.000000000 +0900
@@ -214,7 +214,9 @@
 **      *     zero or more pages numbers of leaves
 */
 #include "sqliteInt.h"
-
+#ifndef SQLITE_OMIT_ROWLOCK
+#include "rowlock.h"
+#endif
 
 /* The following value is the maximum cell size assuming a maximum page
 ** size give above.
@@ -319,6 +321,10 @@
 /* Candidate values for BtLock.eLock */
 #define READ_LOCK     1
 #define WRITE_LOCK    2
+#ifndef SQLITE_OMIT_ROWLOCK
+#define WRITEEX_LOCK  3
+#define EXCLSV_LOCK   4
+#endif
 
 /* A Btree handle
 **
@@ -356,6 +362,9 @@
 #ifndef SQLITE_OMIT_SHARED_CACHE
   BtLock lock;       /* Object used to lock page 1 */
 #endif
+#ifndef SQLITE_OMIT_ROWLOCK
+  BtreeTrans btTrans;
+#endif
 };
 
 /*
@@ -524,6 +533,11 @@
   struct KeyInfo *pKeyInfo;            /* Arg passed to comparison function */
   MemPage *pPage;                        /* Current page */
   MemPage *apPage[BTCURSOR_MAX_DEPTH-1]; /* Stack of parents of current page */
+#ifndef SQLITE_OMIT_ROWLOCK
+  BtCursorTrans btCurTrans;
+  i64 cachedRowid;
+  u8 autoRowid;
+#endif
 };
 
 /*
diff -ru sqlite-src-3250000/src/build.c SQLumDash3.25.0/src/build.c
--- sqlite-src-3250000/src/build.c	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/build.c	2018-09-26 12:01:22.000000000 +0900
@@ -2673,6 +2673,8 @@
   }
 #endif
 
+  ROWLOCK_TABLE_LOCK();
+  
   /* Generate code to remove the table from the master table
   ** on disk.
   */
@@ -3640,6 +3642,8 @@
   }
 #endif
 
+  ROWLOCK_TABLE_LOCK_FOR_INDEX();
+
   /* Generate code to remove the index and from the master table */
   v = sqlite3GetVdbe(pParse);
   if( v ){
diff -ru sqlite-src-3250000/src/func.c SQLumDash3.25.0/src/func.c
--- sqlite-src-3250000/src/func.c	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/func.c	2018-09-26 12:01:22.000000000 +0900
@@ -17,6 +17,7 @@
 #include <stdlib.h>
 #include <assert.h>
 #include "vdbeInt.h"
+#include "funcNew.h"
 
 /*
 ** Return the collating function associated with a function.
@@ -1989,6 +1990,7 @@
     FUNCTION(coalesce,           1, 0, 0, 0                ),
     FUNCTION(coalesce,           0, 0, 0, 0                ),
     FUNCTION2(coalesce,         -1, 0, 0, noopFunc,  SQLITE_FUNC_COALESCE),
+    SQLUMDASH_NEW_FUNCTIONS,
   };
 #ifndef SQLITE_OMIT_ALTERTABLE
   sqlite3AlterFunctions();
SQLumDash3.25.0/src のみに存在: funcNew.c
SQLumDash3.25.0/src のみに存在: funcNew.h
diff -ru sqlite-src-3250000/src/global.c SQLumDash3.25.0/src/global.c
--- sqlite-src-3250000/src/global.c	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/global.c	2018-09-14 17:35:50.000000000 +0900
@@ -242,6 +242,10 @@
    0,                         /* bLocaltimeFault */
    0x7ffffffe,                /* iOnceResetThreshold */
    SQLITE_DEFAULT_SORTERREF_SIZE   /* szSorterRef */
+#ifndef SQLITE_OMIT_ROWLOCK
+   ,ROWLOCK_DEFAULT_MMAP_ROW_SIZE, /* szMmapRowLock */
+   ROWLOCK_DEFAULT_MMAP_TABLE_SIZE /* szMmapTableLock */
+#endif
 };
 
 /*
diff -ru sqlite-src-3250000/src/main.c SQLumDash3.25.0/src/main.c
--- sqlite-src-3250000/src/main.c	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/main.c	2018-09-26 12:01:22.000000000 +0900
@@ -641,6 +641,8 @@
       sqlite3GlobalConfig.nStmtSpill = va_arg(ap, int);
       break;
     }
+    
+    ROWLOCK_MMAP_CONFIG
 
 #ifdef SQLITE_ENABLE_SORTER_REFERENCES
     case SQLITE_CONFIG_SORTERREF_SIZE: {
diff -ru sqlite-src-3250000/src/pager.c SQLumDash3.25.0/src/pager.c
--- sqlite-src-3250000/src/pager.c	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/pager.c	2018-09-26 12:01:22.000000000 +0900
@@ -848,6 +848,10 @@
 # define pagerBeginReadTransaction(z) SQLITE_OK
 #endif
 
+#ifndef SQLITE_AMALGAMATION
+#include "rowlock_pager.c"
+#endif
+
 #ifndef NDEBUG 
 /*
 ** Usage:
@@ -857,7 +861,7 @@
 ** This function runs many asserts to try to find inconsistencies in
 ** the internal state of the Pager object.
 */
-static int assert_pager_state(Pager *p){
+static int assert_pager_state_original(Pager *p){
   Pager *pPager = p;
 
   /* State must be valid. */
@@ -3921,7 +3925,7 @@
 */
 static int pager_wait_on_lock(Pager *pPager, int locktype){
   int rc;                              /* Return code */
-
+  ROWLOCK_WAIT_ON_EXCLUSIVE_LOCK();
   /* Check that this is either a no-op (because the requested lock is 
   ** already held), or one of the transitions that the busy-handler
   ** may be invoked during, according to the comment above
@@ -4397,7 +4401,8 @@
 ** occurs, an IO error code is returned. Or, if the EXCLUSIVE lock cannot
 ** be obtained, SQLITE_BUSY is returned.
 */
-static int pager_write_pagelist(Pager *pPager, PgHdr *pList){
+static int pager_write_pagelist(Pager *pPager, PgHdr *pList);
+static int pager_write_pagelist_original(Pager *pPager, PgHdr *pList){
   int rc = SQLITE_OK;                  /* Return code */
 
   /* This function is only called for rollback pagers in WRITER_DBMOD state. */
SQLumDash3.25.0/src のみに存在: rowlock.c
SQLumDash3.25.0/src のみに存在: rowlock.h
SQLumDash3.25.0/src のみに存在: rowlock_btree.c
SQLumDash3.25.0/src のみに存在: rowlock_hash.c
SQLumDash3.25.0/src のみに存在: rowlock_hash.h
SQLumDash3.25.0/src のみに存在: rowlock_ipc.c
SQLumDash3.25.0/src のみに存在: rowlock_ipc.h
SQLumDash3.25.0/src のみに存在: rowlock_ipc_row.c
SQLumDash3.25.0/src のみに存在: rowlock_ipc_row.h
SQLumDash3.25.0/src のみに存在: rowlock_ipc_table.c
SQLumDash3.25.0/src のみに存在: rowlock_ipc_table.h
SQLumDash3.25.0/src のみに存在: rowlock_macro.h
SQLumDash3.25.0/src のみに存在: rowlock_pager.c
SQLumDash3.25.0/src のみに存在: rowlock_savepoint.c
SQLumDash3.25.0/src のみに存在: rowlock_savepoint.h
diff -ru sqlite-src-3250000/src/sqlite.h.in SQLumDash3.25.0/src/sqlite.h.in
--- sqlite-src-3250000/src/sqlite.h.in	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/sqlite.h.in	2018-10-10 09:14:57.000000000 +0900
@@ -9281,6 +9281,35 @@
 # undef double
 #endif
 
+/* The followings are additional config flag for sqlite3_config. */
+#define SQLITE_CONFIG_MMAP_ROW_SIZE      28  /* int nByte */
+#define SQLITE_CONFIG_MMAP_TABLE_SIZE    29  /* int nByte */
+
+/* New error code for SQLumDash. */
+#define SQLITE_CORRUPT_ROWID 99 /* rowid issued automatically is corrupted. */
+
+/* For the test */
+typedef struct IpcHandle IpcHandle;
+int sqlite3_rowlock_ipc_init(IpcHandle *pHandle, sqlite3_uint64 nByteRow, sqlite3_uint64 nByteTable, const void *owner);
+void sqlite3_rowlock_ipc_finish(IpcHandle *pHandle);
+int sqlite3_rowlock_ipc_lock_record(IpcHandle *pHandle, int iTable, sqlite3_int64 rowid);
+void sqlite3_rowlock_ipc_unlock_record(IpcHandle *pHandle, int iTable, sqlite3_int64 rowid);
+void sqlite3_rowlock_ipc_unlock_record_proc(IpcHandle *pHandle);
+int sqlite3_rowlock_ipc_lock_table(IpcHandle *pHandle, int iTable, unsigned char eLock, unsigned char *prevLock);
+unsigned char sqlite3_rowlock_ipc_lock_table_query(IpcHandle *pHandle, int iTable);
+void sqlite3_rowlock_ipc_unlock_table(IpcHandle *pHandle, int iTable);
+void sqlite3_rowlock_ipc_register_hash_func(int iClass, sqlite3_uint64(*xFunc)(void *pMap, ...));
+typedef struct RowLockSavepoint RowLockSavepoint;
+int sqlite3_rowlock_savepoint_init(RowLockSavepoint *pLockSavepoint);
+void sqlite3_rowlock_savepoint_finish(RowLockSavepoint *pLockSavepoint);
+int sqlite3_rowlock_savepoint_create(RowLockSavepoint *pLockSavepoint, int iSavepoint);
+void sqlite3_rowlock_savepoint_close(RowLockSavepoint *pLockSavepoint, int op, int iSavepoint, IpcHandle *pHandle, void *pRootPages);
+int sqlite3_rowlock_history_add_record(RowLockSavepoint *pLockSavepoint, int iTable, sqlite3_int64 rowid);
+int sqlite3_rowlock_history_add_new_table(RowLockSavepoint *pLockSavepoint, int iTable);
+int sqlite3_rowlock_history_add_table_lock(RowLockSavepoint *pLockSavepoint, int iTable, unsigned char prevLock);
+void sqlite3_rowlock_register_unlockRecord_func(void(*xFunc)(IpcHandle*,int,sqlite3_int64));
+void sqlite3_rowlock_register_lockTable_func(int(*xFunc)(IpcHandle*,int,unsigned char));
+void sqlite3_rowlock_register_rootPageDel_func(void*(*xFunc)(void*,sqlite3_int64,void*));
 #ifdef __cplusplus
 }  /* End of the 'extern "C"' block */
 #endif
diff -ru sqlite-src-3250000/src/sqliteInt.h SQLumDash3.25.0/src/sqliteInt.h
--- sqlite-src-3250000/src/sqliteInt.h	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/sqliteInt.h	2018-09-26 12:01:23.000000000 +0900
@@ -3398,6 +3398,10 @@
   int bLocaltimeFault;              /* True to fail localtime() calls */
   int iOnceResetThreshold;          /* When to reset OP_Once counters */
   u32 szSorterRef;                  /* Min size in bytes to use sorter-refs */
+#ifndef SQLITE_OMIT_ROWLOCK
+  sqlite3_int64 szMmapRowLock;      /* MMAP space for row lock */
+  sqlite3_int64 szMmapTableLock;    /* MMAP space for table lock */
+#endif
 };
 
 /*
diff -ru sqlite-src-3250000/src/trigger.c SQLumDash3.25.0/src/trigger.c
--- sqlite-src-3250000/src/trigger.c	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/trigger.c	2018-09-26 12:01:23.000000000 +0900
@@ -628,6 +628,8 @@
   }
 #endif
 
+  ROWLOCK_TABLE_LOCK_FOR_TRIGGER();
+
   /* Generate code to destroy the database record of the trigger.
   */
   assert( pTable!=0 );
diff -ru sqlite-src-3250000/src/vdbe.c SQLumDash3.25.0/src/vdbe.c
--- sqlite-src-3250000/src/vdbe.c	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/vdbe.c	2018-09-26 12:01:23.000000000 +0900
@@ -20,6 +20,9 @@
 */
 #include "sqliteInt.h"
 #include "vdbeInt.h"
+#ifndef SQLITE_OMIT_ROWLOCK
+#include "rowlock.h"
+#endif
 
 /*
 ** Invoke this macro on memory cells just prior to changing the
@@ -979,7 +982,7 @@
 case OP_Halt: {
   VdbeFrame *pFrame;
   int pcx;
-
+  ROWLOCK_SET_FORCE_COMMIT();
   pcx = (int)(pOp - aOp);
 #ifdef SQLITE_DEBUG
   if( pOp->p2==OE_Abort ){ sqlite3VdbeAssertAbortable(p); }
@@ -3260,7 +3263,7 @@
       }
       goto abort_due_to_error;
     }
-
+    ROWLOCK_ENABLE_STMT_JOURNAL();
     if( pOp->p2 && p->usesStmtJournal 
      && (db->autoCommit==0 || db->nVdbeRead>1) 
     ){
@@ -3577,6 +3580,7 @@
   sqlite3BtreeCursorHintFlags(pCur->uc.pCursor,
                                (pOp->p5 & (OPFLAG_BULKCSR|OPFLAG_SEEKEQ)));
   if( rc ) goto abort_due_to_error;
+  ROWLOCK_CACHED_ROWID_SET_BY_OPEN_CURSOR();
   break;
 }
 
@@ -3960,7 +3964,11 @@
         if( (oc & 0x0001)==(OP_SeekLT & 0x0001) ) oc++;
       }
     } 
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3BtreeMovetoUnpackedAll(pC->uc.pCursor, 0, (u64)iKey, 0, &res, pOp->opcode);
+#else
     rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)iKey, 0, &res);
+#endif
     pC->movetoTarget = iKey;  /* Used by OP_Delete */
     if( rc!=SQLITE_OK ){
       goto abort_due_to_error;
@@ -4004,7 +4012,11 @@
     { int i; for(i=0; i<r.nField; i++) assert( memIsValid(&r.aMem[i]) ); }
 #endif
     r.eqSeen = 0;
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3BtreeMovetoUnpackedAll(pC->uc.pCursor, &r, 0, 0, &res, pOp->opcode);
+#else
     rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, &r, 0, 0, &res);
+#endif
     if( rc!=SQLITE_OK ){
       goto abort_due_to_error;
     }
@@ -4240,7 +4252,11 @@
       }
     }
   }
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeMovetoUnpackedAll(pC->uc.pCursor, pIdxKey, 0, 0, &res, pOp->opcode);
+#else
   rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, pIdxKey, 0, 0, &res);
+#endif
   if( pFree ) sqlite3DbFreeNN(db, pFree);
   if( rc!=SQLITE_OK ){
     goto abort_due_to_error;
@@ -4342,7 +4358,11 @@
   assert( pCrsr!=0 );
   res = 0;
   iKey = pIn3->u.i;
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeMovetoUnpackedAll(pCrsr, 0, iKey, 0, &res, pOp->opcode);
+#else
   rc = sqlite3BtreeMovetoUnpacked(pCrsr, 0, iKey, 0, &res);
+#endif
   assert( rc==SQLITE_OK || res==0 );
   pC->movetoTarget = iKey;  /* Used by OP_Delete */
   pC->nullRow = 0;
@@ -4438,7 +4458,11 @@
 #   define MAX_ROWID  (i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )
 #endif
 
+    ROWLOCK_CACHED_ROWID_FLAG_SET();
     if( !pC->useRandomRowid ){
+#ifndef SQLITE_OMIT_ROWLOCK
+      ROWLOCK_CACHED_ROWID_NEW_ROWID();
+#else
       rc = sqlite3BtreeLast(pC->uc.pCursor, &res);
       if( rc!=SQLITE_OK ){
         goto abort_due_to_error;
@@ -4454,6 +4478,7 @@
           v++;   /* IMP: R-29538-34987 */
         }
       }
+#endif
     }
 
 #ifndef SQLITE_OMIT_AUTOINCREMENT
@@ -4497,8 +4522,13 @@
       do{
         sqlite3_randomness(sizeof(v), &v);
         v &= (MAX_ROWID>>1); v++;  /* Ensure that v is greater than zero */
+#ifndef SQLITE_OMIT_ROWLOCK
+      }while(  ((rc = sqlite3BtreeMovetoUnpackedAll(pC->uc.pCursor, 0, (u64)v,
+                                                 0, &res, pOp->opcode))==SQLITE_OK)
+#else
       }while(  ((rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)v,
                                                  0, &res))==SQLITE_OK)
+#endif
             && (res==0)
             && (++cnt<100));
       if( rc ) goto abort_due_to_error;
@@ -4512,6 +4542,7 @@
     pC->cacheStatus = CACHE_STALE;
   }
   pOut->u.i = v;
+  ROWLOCK_CACHED_ROWID_SET();
   break;
 }
 
@@ -4586,6 +4617,7 @@
     assert( memIsValid(pKey) );
     REGISTER_TRACE(pOp->p3, pKey);
     x.nKey = pKey->u.i;
+    ROWLOCK_CACHED_ROWID_UPDATE();
   }else{
     assert( pOp->opcode==OP_InsertInt );
     x.nKey = pOp->p3;
@@ -4627,9 +4659,15 @@
     x.nZero = 0;
   }
   x.pKey = 0;
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3TransBtreeInsert(pC->uc.pCursor, &x,
+      (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)), seekResult
+  );
+#else
   rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
       (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)), seekResult
   );
+#endif
   pC->deferredMoveto = 0;
   pC->cacheStatus = CACHE_STALE;
 
@@ -4758,7 +4796,11 @@
   }
 #endif
 
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3TransBtreeDelete(pC->uc.pCursor, pOp->p5);
+#else
   rc = sqlite3BtreeDelete(pC->uc.pCursor, pOp->p5);
+#endif
   pC->cacheStatus = CACHE_STALE;
   pC->seekResult = 0;
   if( rc ) goto abort_due_to_error;
@@ -5144,7 +5186,11 @@
     assert( pC->eCurType==CURTYPE_BTREE );
     pCrsr = pC->uc.pCursor;
     assert( pCrsr );
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3BtreeFirstAll(pCrsr, &res);
+#else
     rc = sqlite3BtreeFirst(pCrsr, &res);
+#endif
 #ifndef SQLITE_OMIT_WINDOWFUNC
     if( pOp->p5 ) sqlite3BtreeSkipNext(pCrsr);
 #endif
@@ -5248,7 +5294,11 @@
        || pC->seekOp==OP_Last 
        || pC->seekOp==OP_NullRow);
 
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeAdvanceAll(pC->uc.pCursor, pOp->p3, pOp->p4.xAdvance);
+#else
   rc = pOp->p4.xAdvance(pC->uc.pCursor, pOp->p3);
+#endif
 next_tail:
   pC->cacheStatus = CACHE_STALE;
   VdbeBranchTaken(rc==SQLITE_OK,2);
@@ -5325,10 +5375,17 @@
     x.pKey = pIn2->z;
     x.aMem = aMem + pOp->p3;
     x.nMem = (u16)pOp->p4.i;
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3TransBtreeInsert(pC->uc.pCursor, &x,
+         (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)), 
+        ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0)
+        );
+#else
     rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
          (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)), 
         ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0)
         );
+#endif
     assert( pC->deferredMoveto==0 );
     pC->cacheStatus = CACHE_STALE;
   }
@@ -5363,10 +5420,18 @@
   r.nField = (u16)pOp->p3;
   r.default_rc = 0;
   r.aMem = &aMem[pOp->p2];
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeMovetoUnpackedAll(pCrsr, &r, 0, 0, &res, pOp->opcode);
+#else
   rc = sqlite3BtreeMovetoUnpacked(pCrsr, &r, 0, 0, &res);
+#endif
   if( rc ) goto abort_due_to_error;
   if( res==0 ){
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3TransBtreeDelete(pCrsr, BTREE_AUXDELETE);
+#else
     rc = sqlite3BtreeDelete(pCrsr, BTREE_AUXDELETE);
+#endif
     if( rc ) goto abort_due_to_error;
   }
   assert( pC->deferredMoveto==0 );
@@ -5597,7 +5662,11 @@
     iDb = pOp->p3;
     assert( DbMaskTest(p->btreeMask, iDb) );
     iMoved = 0;  /* Not needed.  Only to silence a warning. */
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3BtreeDropTableAll(db->aDb[iDb].pBt, pOp->p1, &iMoved);
+#else
     rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved);
+#endif
     pOut->flags = MEM_Int;
     pOut->u.i = iMoved;
     if( rc ) goto abort_due_to_error;
@@ -5638,9 +5707,15 @@
   nChange = 0;
   assert( p->readOnly==0 );
   assert( DbMaskTest(p->btreeMask, pOp->p2) );
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3TransBtreeClearTable(
+      db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &nChange : 0)
+  );
+#else
   rc = sqlite3BtreeClearTable(
       db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &nChange : 0)
   );
+#endif
   if( pOp->p3 ){
     p->nChange += nChange;
     if( pOp->p3>0 ){
@@ -6762,7 +6837,11 @@
     int p1 = pOp->p1; 
     assert( p1>=0 && p1<db->nDb );
     assert( DbMaskTest(p->btreeMask, p1) );
+#ifndef SQLITE_OMIT_ROWLOCK
+    assert( isWriteLock==0 || isWriteLock==1 || isWriteLock==2 );
+#else
     assert( isWriteLock==0 || isWriteLock==1 );
+#endif
     rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);
     if( rc ){
       if( (rc&0xFF)==SQLITE_LOCKED ){
diff -ru sqlite-src-3250000/src/vdbeapi.c SQLumDash3.25.0/src/vdbeapi.c
--- sqlite-src-3250000/src/vdbeapi.c	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/vdbeapi.c	2018-09-26 12:01:23.000000000 +0900
@@ -16,6 +16,8 @@
 #include "sqliteInt.h"
 #include "vdbeInt.h"
 
+ROWLOCK_CACHED_ROWID_RETRY
+
 #ifndef SQLITE_OMIT_DEPRECATED
 /*
 ** Return TRUE (non-zero) of the statement supplied as an argument needs
@@ -543,7 +545,7 @@
 ** schema change has occurred.  That detail is handled by the
 ** outer sqlite3_step() wrapper procedure.
 */
-static int sqlite3Step(Vdbe *p){
+static int sqlite3StepOriginal(Vdbe *p){
   sqlite3 *db;
   int rc;
 
diff -ru sqlite-src-3250000/src/vdbeaux.c SQLumDash3.25.0/src/vdbeaux.c
--- sqlite-src-3250000/src/vdbeaux.c	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/src/vdbeaux.c	2018-09-26 12:01:23.000000000 +0900
@@ -14,6 +14,9 @@
 */
 #include "sqliteInt.h"
 #include "vdbeInt.h"
+#ifndef SQLITE_OMIT_ROWLOCK
+#include "rowlock.h"
+#endif
 
 /*
 ** Create a new virtual database engine.
@@ -2827,6 +2830,11 @@
           }
           rc = SQLITE_CONSTRAINT_FOREIGNKEY;
         }else{ 
+#ifndef SQLITE_OMIT_ROWLOCK
+          rc = sqlite3BtreeBeginTransForCommit(db);
+          if( rc ) return rc;
+#endif
+
           /* The auto-commit flag is true, the vdbe program was successful 
           ** or hit an 'OR FAIL' constraint and there are no deferred foreign
           ** key constraints to hold up the transaction. This means a commit 
@@ -2901,6 +2909,10 @@
     sqlite3VdbeLeave(p);
   }
 
+#ifndef SQLITE_OMIT_ROWLOCK
+  sqlite3BtreeUnlockStmtTableLock(db);
+#endif
+
   /* We have successfully halted and closed the VM.  Record this fact. */
   if( p->pc>=0 ){
     db->nVdbeActive--;
@@ -3204,7 +3216,11 @@
   assert( p->deferredMoveto );
   assert( p->isTable );
   assert( p->eCurType==CURTYPE_BTREE );
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeMovetoUnpackedAll(p->uc.pCursor, 0, p->movetoTarget, 0, &res, 0);
+#else
   rc = sqlite3BtreeMovetoUnpacked(p->uc.pCursor, 0, p->movetoTarget, 0, &res);
+#endif
   if( rc ) return rc;
   if( res!=0 ) return SQLITE_CORRUPT_BKPT;
 #ifdef SQLITE_TEST
diff -ru sqlite-src-3250000/tool/mksqlite3c-noext.tcl SQLumDash3.25.0/tool/mksqlite3c-noext.tcl
--- sqlite-src-3250000/tool/mksqlite3c-noext.tcl	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/tool/mksqlite3c-noext.tcl	2018-09-26 12:01:23.000000000 +0900
@@ -119,6 +119,12 @@
    vxworks.h
    wal.h
    whereInt.h
+   rowlock.h
+   rowlock_hash.h
+   rowlock_ipc.h
+   rowlock_ipc_table.h
+   rowlock_ipc_row.h
+   rowlock_savepoint.h
 } {
   set available_hdr($hdr) 1
 }
@@ -336,6 +342,7 @@
    callback.c
    delete.c
    func.c
+   funcNew.c
    fkey.c
    insert.c
    legacy.c
@@ -353,6 +360,15 @@
    where.c
    window.c
 
+   rowlock.c
+   rowlock_btree.c
+   rowlock_hash.c
+   rowlock_ipc.c
+   rowlock_ipc_row.c
+   rowlock_ipc_table.c
+   rowlock_pager.c
+   rowlock_savepoint.c
+
    parse.c
 
    tokenize.c
diff -ru sqlite-src-3250000/tool/mksqlite3c.tcl SQLumDash3.25.0/tool/mksqlite3c.tcl
--- sqlite-src-3250000/tool/mksqlite3c.tcl	2018-09-15 20:35:52.000000000 +0900
+++ SQLumDash3.25.0/tool/mksqlite3c.tcl	2018-09-26 12:01:23.000000000 +0900
@@ -127,6 +127,12 @@
    vxworks.h
    wal.h
    whereInt.h
+   rowlock.h
+   rowlock_hash.h
+   rowlock_ipc.h
+   rowlock_ipc_table.h
+   rowlock_ipc_row.h
+   rowlock_savepoint.h
 } {
   set available_hdr($hdr) 1
 }
@@ -354,6 +360,7 @@
    callback.c
    delete.c
    func.c
+   funcNew.c
    fkey.c
    insert.c
    legacy.c
@@ -372,6 +379,15 @@
    where.c
    window.c
 
+   rowlock.c
+   rowlock_btree.c
+   rowlock_hash.c
+   rowlock_ipc.c
+   rowlock_ipc_row.c
+   rowlock_ipc_table.c
+   rowlock_pager.c
+   rowlock_savepoint.c
+
    parse.c
 
    tokenize.c
SQLumDash3.25.0/tool のみに存在: rowlock_cleaner.c
SQLumDash3.25.0/tool/win のみに存在: uniq.bat
